'use strict';

//«унарный», «бинарный», «операнд»
// let x = 1
// операнд -- это аргумент, к котором непосредственно применяется оператор
// x = -x;
// alert( x ); // -1, применили унарный минус

// let a = 1, b = 3;
// alert( a - b ); // 2, бинарный минус вычитает значения

// alert( 5 % 2 ); // 1, остаток от деления 5 на 2, % - оператор взятия остатка от деления

// alert( 2 ** 2 ); // 2² = 4, ** - возводит в степень

// бинарный "+"
// let s = "моя" + "строка";
// alert(s); // "моястрока"
// alert( '1' + 2 ); // "12" при этом стоит отметить, что если один из операндов строка, то и результат будет строкой
// !!!===== данное свойство характерно только для бинарного + ====!!! все другие операторы приводят к ЧИСЛУ

//унарный "+" - преобразует операнд в число, 
// let apples = "2";
// let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5
// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5

//Присваивание = возвращает значение
let g = 2 * 2 + 1;

alert( x ); // 5

//Присваивание по цепочке
// let f, d, c;

f = d = c = 2 + 2;

alert( f ); // 4
alert( d ); // 4
alert( c ); // 4

//Сокращённая арифметика с присваиванием
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 2)
alert( n ); // 14

let w = 2;
w *= 3 + 5; // имеет такой же вес как и обычный оператор присваивания
alert( w ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)

// ПОБИТОВЫЕ ОПЕРАТОРЫ
/* AND(и) ( & )
OR(или) ( | )
XOR(побитовое исключающее или) ( ^ )
NOT(не) ( ~ )
LEFT SHIFT(левый сдвиг) ( << )
RIGHT SHIFT(правый сдвиг) ( >> )
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> ) */

//Оператор ЗАПЯТАЯ
//имеет очень низкий приоритет, ниже =, поэтому скобки важны
let i = (1 + 2, 3 + 4);

alert( i ); // 7 (результат вычисления 3 + 4) возвращается результат только последнего.

// три операции в одной строке
/* for (a = 1, b = 3, c = a * b; a < 10; a++) {
	...
   } */

   //=====ЗАДАНИЕ====//
// let a = 1, b = 1;

let c = ++a; // 2
let d = b++; // 1 
  //=====ЗАДАНИЕ====//
// let a = 2;
let x = 1 + (a *= 2);// a=4 x=5
  //=====ЗАДАНИЕ====//
"" + 1 + 0 // NaN !!! неправильно тк если строка есть, то и все строки "10"
"" - 1 + 0 // Nan !!! "" будет приравна к 0 получится -1
true + false // 1
6 / "3" // 2
"2" * "3" //6
4 + 5 + "px" //9px
"$" + 4 + 5 //$45
"4" - 2 // 2
"4px" - 2 // NaN
"  -9  " + 5 // "-95"
"  -9  " - 5 // -14
null + 1 // 1
undefined + 1 // NaN
" \t \n" - 2 // Пробельные символы, такие как \t и \n, по краям строки игнорируются при преобразовании в число, так что строка " \t \n", аналогично пустой строке, становится 0 после численного преобразования.

//=====ЗАДАНИЕ====//
let a = prompt("Первое число?", 1);
let b = prompt("Второе число?", 2);

alert(+a + +b); // 12